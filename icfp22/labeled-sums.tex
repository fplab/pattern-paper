\section{Labeled Sums}\label{sec:labeledsums}

In this section, we will conservatively extend Peanut with finite labeled sums,
sometimes called tagged unions or discrimnated unions.

The first step is to generalize the syntax of binary sums to other than two variants:
\[
  \arraycolsep=4pt\begin{array}{lll}
    \tau & ::= & \ldots ~\vert~ \tlabeledsum{C_i(\tau_i)}_{C_i \in \tagset} \\
    e    & ::= & \ldots ~\vert~ \hinj{C}{\tau}{e}                           \\
    p    & ::= & \ldots ~\vert~ \hinjp{C}{p}                                \\
    C    & ::= & \tagC ~\vert~ \tagehole{u} ~\vert~ \taghole{\tagC}{u}
  \end{array}
\]
Labeled sums introduce a sort $C$ for labels and a new type-level connective
\[ C_1(\tau_1) + \cdots + C_n(\tau_n) \]
for collecting and labeling types.
Since we are not concerned with the length of any particular sum,
we employ the more general and compact notation
\[\tlabeledsum{C_i(\tau_i)}_{C_i \in \tagset}\]
for a sum consisting of labels $\tagset = \setof{C_i}_{i \leq n}$ with respective argument types $\setof{\tau_i}_{i \leq n}$.
The introductory form is the \emph{labeled injection} $\hinj{C}{\tau}{e}$ of expression $e$ into sum type $\tau$ at label $C$.
The elimination form is $\hinj{C}{\tau}{p}$ via pattern matching.

To facilitate gap-free editing of injection expressions and patterns, we distinguish between \emph{concrete labels} $\tagC$
and \emph{label holes} which may be empty $\tagehole{u}$ or not empty $\taghole{\tagC}{u}$.
Empty label holes indicate positions where labels are expected but not present.
Non-empty label holes contain labels that are either syntactically invalid or violate semantic constraints.
Whereas syntactic validity is essentially arbitrary, the semantic validity of a label is determined by the sort of its parent term.
A label in type position is part of a sum type declaration and so must be unique w.r.t. other labels in the same declaration.
A label in expression position is part of a labeled injection and so must belong to the intended sum type.

% Moving on to the static semantics, we must first extend the typing relations as shown in .

% \input{fig-labeled-sums-dynamics}
% \input{fig-labeled-sums-statics}
% \input{fig-labeled-sums-decidability}

% (statics)

% The presence of holes poses interesting challenges for the formal treatment of labeled sums.
% Consistency of labeled sum types is more nuanced than for binary sums.
% For example, consistency of sums of the same cardinality depends on whether there is a consistent mapping between tags as well as argument types.
% (Say something about the algorithmic complexity of naive vs our efficient implementation? Cite even more efficient approaches?)

% consistency: (efficient?) matching (we build a bipartite graph of all possible consistent matchings and use Hopcroft-Karp maximum-cardinality matching algo to determine whether a maximum matching exists)

% % dont need: elided sums: easy to synthesize and enable a broader notion of consistency
% % dont need: casts between sums: (we do it componentwise)
% % dont need: (matched finite sums?)

% (dynamics)

% substitution does not affect tags directly (but does affect argument types)

% injection constraints (e.g. "not inl")
% + any other modifications to the formalism to make labeled sums work

% any interesting details w.r.t. exhaustiveness or redundancy?
% - duals
% - see if existing definitions or operations need a richer understanding of sums than binary
