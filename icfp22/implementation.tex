\section{Implementation}
\subsection{Hazel}
We add constraints and inconsistent judgements to Hazel to support holes in case expression. Although Hazel enjoys richer types, such as bool and float, than Peanut, all of those can be easily generalized using methods discussed in this paper. Float can be treated exactly as num in this paper. Bool type can be viewed as one sum type. For this reason, we use InjL(Truth) and InjR(Truth) to bound True and False, respectively. After fixing syntax for the case expression, we emits the constraints and check for redundancy and exhaustiveness and generate errors accordingly.

\subsection{Mechanization}
Our described system is fairly intricate, with many of the proofs requiring significant case-work. Thus, to ensure no details have been overlooked, the archived artifact also contains a mechanization of the semantics and metatheory of Peanut using the Agda proof assistant \todo{cite}. This includes \emph{almost} all of the theorems and lemmas stated above and in the appendix, excluding the labeled sums extension outlined in \autoref{sec:labeledsums}. The only notable results not mechanized are those related to constraint consistency and the decidability of constraint entailment. Such proofs require reasoning about finite sets in a non-structurally recursive way, making them inordinately difficult to verify in Agda. Instead, we make use of the Z3 Theorem Prover, \todo{cite} showing that the incon judgement is equivalent to a decidable SAT problem.

In general, our mechanization takes an approach similar to that used in the mechanization of Hazelnut Live.\todo{cite} As is standard, judgements are encoded as inductive datatypes, and their rules are encoded as dependently typed constructors thereof. For variable and hole names, note that on paper, we silently assume that we may $\alpha$-rename terms as needed. In our mechanization, rather than explicitly performing such renaming, we insert appropriate uniqueness constraints as a premise to each theorem. Additionally, we make explicit assumptions about disjointness between bound variables and typing contexts. This is a slightly generalized version of Barendregt’s convention for bound variables \todo{cite}, and all such premises are fairly benign, as they can always be satisfied by some $\alpha$-equivalent term.

Furthermore, again following the mechanization of Hazelnut Live, we restrict variable names to natural numbers, and we encode typing contexts and hole contexts as metafunctions $\mathbb{N} \to \text{Maybe } T$ for appropriate types $T$. While not strictly necessary, we postulate function extensionality to improve the ergonomics of such an encoding. Function extensionality is known to be independent of Agda’s axioms \todo{cite}, and we assume no other postulates.

In a few places, the mechanization also differs slightly from the definitions laid out on paper. Most notably, the mechanization removes exhaustiveness and redundancy checking from the typing judgement, and instead includes them separately as their own judgements. This has the advantage of making these checks optional, while also avoiding a morally-irrelevant but technically-inconvenient positivity issue with the encoding of the typing judgement in Agda. As a consequence, we also prove separate preservation theorems for each of these judgements. The documentation provided with the mechanization has more details, enumerating all deviations from the paper and their motivation.