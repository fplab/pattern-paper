\section{Implementation}
\subsection{Hazel}
We add constraints and inconsistent judgements to Hazel to support holes in case expression. Although Hazel enjoys richer types, such as bool and float, than Peanut, all of those can be easily generalized using methods discussed in this paper. Float can be treated exactly as num in this paper. Bool type can be viewed as one sum type. For this reason, we use InjL(Truth) and InjR(Truth) to bound True and False, respectively. After fixing syntax for the case expression, we emits the constraints and check for redundancy and exhaustiveness and generate errors accordingly.

\subsubsection{incon judgment}

In \autoref{sec:decidability}, we use Z3 Theorem Prover as a SAT solver to determine the constraint entailments. However, it is not only an overkill but also may incur run-time and space overhead to the development environment. When incorporating Peanut into Hazel, we use a different but more lightweight decision procedure. \figurename~\ref{fig:incon} describes such procedure by defining a new judgment $\cincon{\Xi}$. Assuming constraint $\xi$ is fully known and is of type $\tau$, $\cincon{\xi}$ means constraint $\xi$ is inconsistent in the sense that no values of type $\tau$ satisfy $\xi$, which corresponds to the insatisfiability of $\xi$'s logical encoding. Therefore, a constraint is valid, written as $\ccsatisfy{}{\xi}$, iff its dual is inconsistent, written as $\cincon{\cdual{\xi}}$.

\input{fig-incon}

\subsection{Mechanization}
Our described system is fairly intricate, with many of the proofs requiring significant case-work. Thus, to ensure no details have been overlooked, the archived artifact also contains a mechanization of the semantics and metatheory of Peanut using the Agda proof assistant \cite{norell:thesis}. This includes \emph{almost all} of the theorems and lemmas stated above and in the appendix, excluding the labeled sums extension outlined in \autoref{sec:labeledsums}. The only notable results not mechanized are those related to constraint consistency and the decidability of constraint entailment. Such proofs require reasoning about finite sets in a non-structurally recursive way, making them inordinately difficult to verify in Agda.

In general, our mechanization takes an approach similar to that used in the mechanization of Hazelnut Live \cite{DBLP:journals/pacmpl/OmarVCH19}. As is typical in Agda, judgements are encoded as inductive datatypes, and their rules are encoded as dependently typed constructors thereof. For variable and hole names, note that on paper, we ignore issues related to shadowing, and implicitly assume that we may $\alpha$-convert terms as needed. In our mechanization, rather than explicitly performing such renaming, we insert appropriate uniqueness constraints as a premise to each theorem. Additionally, we make assumptions about disjointness between bound variables and typing contexts, following a slightly generalized version of Barendregt’s convention \cite{DBLP:books/daglib/0067558, DBLP:conf/cade/UrbanBN07}. All such premises are fairly benign, as they can always be satisfied by some $\alpha$-equivalent term.

Furthermore, again following the mechanization of Hazelnut Live, we restrict variable names to natural numbers, and we encode typing contexts and hole contexts as metafunctions $\mathbb{N} \to \text{Maybe } T$ for appropriate types $T$. While not strictly necessary, we postulate function extensionality to improve the ergonomics of such an encoding. This postulate is fairly innocuous, as function extensionality is known to be independent of Agda’s axioms \cite{DBLP:conf/lics/AwodeyGS12}. We assume no other postulates.

In a few places, the mechanization also differs slightly from the definitions laid out on paper. Most notably, the mechanization removes exhaustiveness and redundancy checking from the typing judgement, and instead includes them separately as their own judgements. This has the advantage of making these checks optional, while also avoiding a morally-irrelevant but technically-inconvenient positivity issue with the encoding of the typing judgement in Agda. As a consequence, we also prove separate preservation theorems for each of these judgements. The documentation provided with the mechanization has more details, enumerating all deviations from the paper and their motivation.