\RequirePackage{etex}
\documentclass[runningheads,envcountsame,a4paper]{llncs}

\usepackage[T1]{fontenc} % fix missing font cmtt
\usepackage{amsmath}
\usepackage{amssymb} % Vdash
\usepackage{graphicx} % rotatebox
\usepackage{stmaryrd} % llparenthesis
\usepackage{anyfontsize} % workaround for font size difference warning
\usepackage{listings}
\usepackage{tikz}
\usetikzlibrary{calc,fit,tikzmark,plotmarks,arrows.meta,positioning,overlay-beamer-styles}
\usepackage[caption=false]{subfig}

\usepackage{cancel} % slash over symbol
\usepackage{hyperref}
\renewcommand\UrlFont{\color{blue}\rmfamily}

\usepackage{xcolor}
\definecolor{hazelgreen}{RGB}{7,63,36}
\definecolor{hazellightgreen}{RGB}{103,138,97}
\definecolor{hazelyellow}{RGB}{245,222,179}
\definecolor{hazellightyellow}{RGB}{254,254,234}

\newcommand{\highlight}[1]{\colorbox{yellow}{$\displaystyle #1$}}

\newcommand{\todo}[1]{{\color{red} TODO: #1}}

%% Joshua Dunfield macros
\def\OPTIONConf{1}
\usepackage{jdunfield}
\usepackage{rulelinks} % hyperlink of rule name
\input{macros}
\input{rulecommands}

\begin{document}
  
\title{Pattern Matching with Typed Holes}

\author{
  Yongwei Yuan\inst{1} \and 
}
\authorrunning{Y. Yuan et al.}
\institute{
  Purdue University, West Lafayette, USA \\
  \email{yuan311@purdue.edu} \and
  University of Michigan, Ann Arbor, USA
  \email{\{dmoo,hkpotter,wyuning,comar\}@umich.edu}}


\maketitle

\begin{abstract}
  The abstract should briefly summarize the contents of the paper in
  15--250 words.
  
  \keywords{live programming  \and typed holes \and contextual modal type theory.}
\end{abstract}

\section{Introduction}
\label{sec:intro}
Most contemporary programming environments either provide meaningful feedback only for complete programs, or fall back to limited heuristic approaches when the program is incomplete.
Recent work on modeling incomplete programs as typed expressions with \emph{holes} has focused on tackling this problem. \cite{DBLP:conf/popl/OmarVHAH17} describes a static semantics for incomplete functional programs. Based on that, \cite{DBLP:journals/pacmpl/OmarVCH19} develops a dynamic semantics to evaluate such incomplete programs.
These foundational treatments are being implemented and extended in the Hazel programming environment (hazel.org).

\emph{Pattern matching} is a cornerstone of functional programming languages in the ML family. 
However, \cite{DBLP:journals/pacmpl/OmarVCH19} only supports simple case analysis on binary sum types and does not support nested patterns nor pattern holes.
This paper addresses this problem, focusing on adding full ML-style pattern matching with support for pattern holes to the Hazelnut core calculus and implementing 
this system at full scale into Hazel. Consider the examples below, which contain expression and pattern holes, denoted $\hehole{u}$ (where each hole has a unique name, $u$). 

For the match expression shown in \Eqref{eq:complete}, the scrutinee contains a hole.
By considering the match two rules in order, we observe that
no matter how the hole $u$ is filled, $\hpair{\hinl{\tnum}{\hehole{u}}}{2}$ doesn't match $\hpair{\hinrp{x}}{\_}$,
and always matches $\hpair{\_}{x}$. And thus the value of the match expression is $2$, despite the fact that the program is incomplete.
If, however, we replaced the pattern in the first rule with $(\hinlp{3}, \_)$, it would be impossible to decide whether the pattern matches
or not, and so the match expression would be \emph{indeterminate}, i.e. awaiting hole filling.
%Similarly, if we had replaced the pattern in the first rule with $(\hinlp{x}, \hehole{w})$,
%then it is impossible to tell whether the pattern hole $w$ will match $2$ or not,
%so the match would also be indeterminate.

One of the benefits of pattern matching is that it allows for static reasoning about exhaustiveness and redundancy.
However, reasoning about these matters is subtle and complicated in the presence of holes. 
For example, consider the problem of checking if the rules in \Eqref{eq:pathole-exhaustive} cover all the possibilities, \ie \emph{exhaustiveness}, or if the second rule in \Eqref{eq:pathole-redundant} can never be reached no matter how the holes are filled, \ie \emph{redundancy}. 

This abstract focuses on the formalism of full-fledged pattern matching with typed holes so that the programming environment could give this sort of feedback even when considering incomplete match expressions.

\section{Live Pattern Matching}\label{sec:examples}

\begin{figure}[ht]
  \begin{tikzpicture}[remember picture, overlay]
    \node[rotate=-90,mark size=5pt,color=hazellightgreen,shift={(-0.1,-0.2)}] at (pic cs:exp-hole-1) {\pgfuseplotmark{triangle*}};
    \node[rotate=-90,mark size=5pt,color=hazellightgreen,shift={(-0.1,-0.2)}] at (pic cs:exp-hole-2) {\pgfuseplotmark{triangle*}};
  \end{tikzpicture}

  \centering
  \hspace*{\fill}%
  \captionsetup[subfloat]{labelformat=empty}
  \subfloat[]{%
    \makebox[\width]{
      $\begin{aligned}
        &\match (1::\?) \{ \\
        &\tikzmark{exp-hole-1}|~ \hrul{\nil}{\none} \\
        &|~ \hrul{x::xs}{\some{xs}} \\
        &\}
      \end{aligned}$
    }
  }%
  $\mapsto$
  \subfloat[]{
    \makebox[1.2\width]{
      $\begin{aligned}
        &\match (1::\?) \{ \\
        &|~ \hrul{\nil}{\none} \\
        &\tikzmark{exp-hole-2}|~ \hrul{1::xs}{\some{xs}} \\
        &\}
      \end{aligned}$
    }
  }%
  $\mapsto$
  \subfloat[]{
    $\some{?}$
  }
  \hspace*{\fill}%
  \caption{Pattern Matching with Expression Holes}
  \label{fig:exp-hole-step}
\end{figure}

\begin{figure}[ht]
  \begin{tikzpicture}[remember picture, overlay]
    \node[rotate=-90,mark size=5pt,color=hazellightgreen,shift={(-0.1,-0.2)}] at (pic cs:pat-hole-1) {\pgfuseplotmark{triangle*}};
    \node[rotate=-90,mark size=5pt,color=hazellightgreen,shift={(-0.1,-0.2)}] at (pic cs:pat-hole-2) {\pgfuseplotmark{triangle*}};
  \end{tikzpicture}

  \centering
  \hspace*{\fill}%
  \captionsetup[subfloat]{labelformat=empty}
  \subfloat[]{%
    \makebox[\width]{
      $\begin{aligned}
        &\match (1::\nil) \{ \\
        &\tikzmark{pat-hole-1}|~ \hrul{\nil}{\none} \\
        &|~ \hrul{\?::xs}{\some{xs}} \\
        &\}
      \end{aligned}$
    }
  }%
  $\mapsto$
  \subfloat[]{
    \makebox[1.2\width]{
      $\begin{aligned}
        &\match (1::\nil) \{ \\
        &|~ \hrul{\nil}{\none} \\
        &\tikzmark{pat-hole-2}|~ \hrul{\?::xs}{\some{xs}} \\
        &\}
      \end{aligned}$
    }
  }%
  $\not\mapsto$(indeterminate)
  \hspace*{\fill}%
  \caption{Pattern Matching with Pattern Holes}
  \label{fig:pat-hole-step}
\end{figure}

\begin{figure}[ht]
  \centering
  \hspace*{\fill}%
  \subfloat[May or may not be exhaustive.\label{fig:may-exhaustive}]{
    \makebox[2\width]{
      $\begin{aligned}
        &\match (1::\nil) \{ \\
        &|~ \hrul{\nil}{\none} \\
        &|~ \hrul{\?::xs}{\some{xs}} \\
        &\}
      \end{aligned}$
    }
  }%
  \hfill%
  \subfloat[Must not be exhaustive.\label{fig:not-exhasutive}]{
    \makebox[2\width]{
      $\begin{aligned}
        &\match (1::\nil) \{ \\
        &|~ \hrul{\nil}{\none} \\
        &|~ \hrul{1::\?}{\?} \\
        &\}
      \end{aligned}$
    }
  }%
  \hspace*{\fill}%
  \caption{Exhaustiveness Checking in Incomplete Match Expressions}
  \label{fig:exh-hole}
\end{figure}

\begin{figure}[ht]
  \centering
  \hspace*{\fill}%
  \subfloat[May or may not be redundant.\label{fig:may-redundant}]{
    \makebox[1.3\width]{
      $\begin{aligned}
        &\match (1::2::\nil) \{ \\
        &|~ \hrul{\nil}{\none} \\
        &|~ \hrul{x::\?}{\?} \\
        &|~ \hrul{1::xs}{\some{2::xs}} \\
        &\}
      \end{aligned}$
    }
  }%
  \hfill%
  \subfloat[Must be redundant.\label{fig:redundant}]{
    \makebox[1.3\width]{
      $\begin{aligned}
        &\match (1::2::\nil) \{ \\
        &|~ \hrul{\nil}{\none} \\
        &|~ \hrul{x::xs}{\some{xs}} \\
        &|~ \hrul{\?::xs}{\some{xs}} \\
        &\}
      \end{aligned}$
    }
  }%
  \hspace*{\fill}%
  \caption{Redundancy Checking in Incomplete Match Expressions}
  \label{fig:red-hole}
\end{figure}

\section{The Core Calculus}
With the intuition developed in the previous section, we can formally specify
what we mean by pattern matching with holes and also build the type system to
give eager feedback while the user is programming.

\input{fig-syntax}

\paragraph{Overview.}
The syntax of the core calculus is given in \figurename~\ref{fig:syntax}. To
balance simplicity and power of pattern matching with holes, we use number as
the base type and include function type, product type, and sum type in the
calculus. For each type, there is a corresponding expression serving as the
introduction of the type. Besides, holes, as missing parts in a program, can be
of any type (see Sec.~\ref{sec:statics}). And the most interesting part is the
syntax of match expressions. A match expression consists of an expression,
called scrutinee, and zipper rules \todo{ref}. Zipper rules denotes a series of
rules with a pointer on the current rule being considered in runtime (see
Sec.~\ref{sec:dynamics}). As in other ML languages, each rule consists of a
pattern and an expression \todo{ref}. And just like expressions, patterns may
also involve holes and are assigned corresponding types (see Sec.~\ref{sec:statics}).

\subsection{Dynamic Semantics}\label{sec:dynamics}
Pattern matching happens during runtime and the dynamic semantics motivates the
design of the static semantics in Sec.~\ref{sec:statics}. And thus, we start by
taking a step further from the examples shown in
\listfigurename~\ref{fig:exp-hole-step},\ref{fig:pat-hole-step}, and formalize
the heuristic in the stepping judgment.

\input{fig-pointer-eraser}
\input{fig-step}

In Sec.~\ref{sec:examples}, we use a rule pointer to simulate the process in
which we consider the rules in order. However in the syntax of the core
calculus, we use zipper rules of the form $\zrulsP{rs}{r}{rs}$ in match
expressions to represent the intermediate states when we are performing pattern
matching. The former $rs$ represents the preceding rules that has already been
considered and fails to match the scrutinee; the rule $r$ in the middle
represents the current rule being considered; the latter $rs$ represents the
remaining rules to be considered. \figurename~\ref{fig:pointer-eraser} defines a helper function to flatten the zipper rules. Corresponding to moving the rule pointer, we
can append the current rule after the preceding rules, and regard the initial
rule in the remaining rule as the new current rule. The conclusion of
\ITFailMatch demonstrates how it works. 

\input{fig-final}

\figurename~\ref{fig:step} defines the stepping judgment
$\htrans{e}{e'}$. We will focus on stepping judgments of match expressions.
Rule \ITExpMatch specifies that the match expression can take a step as its its
scrutinee can take a step. Note that Rule \ITFailMatch and Rule \ITSuccMatch
share the premise, $\isFinal{e}$, which is defined in \figurename~\ref{fig:final}. It
means that expression $e$ is \textit{final} in the sense that it is either already a
\textit{value} or \textit{indeterminate}, \ie, cannot be evaluated further due to unfilled holes
\cite{DBLP:journals/pacmpl/OmarVCH19}. And only when the scrutinee is final,
shall we consider the constinuent rules of the match expression in order. As in
the examples shown in \listfigurename~\ref{fig:exp-hole-step},\ref{fig:pat-hole-step},

\begin{itemize}
  \item
    if the final scrutinee does not match the pattern in the current rule,
    then we move the pointer to the next rule (Rule \ITFailMatch)

  \item
    if the final scrutinee does match the pattern in the current rule, 
    then we take the emitted substitution $\theta$ and apply it on the subexpression of that rule (Rule \ITSuccMatch)

  \item 
    if the final scrutinee may or may not match the pattern in the current rule,
    then the match expression is said to be indeterminate (Rule \IMatch)
\end{itemize}

\input{fig-patmatch}

\figurename~\ref{fig:patmatch} defines three judgments corresponding to the
three possible results of pattern matching. We consider a final scrutinee $e$
and a pattern $p$ that are of the same type (see Sec.~\ref{sec:statics}). The
judgment $\hpatmatch{e}{p}{\theta}$ denotes that $e$ matches $p$, emitting a
substitution of variables in $p$, while the judgment $\hnotmatch{e}{p}$ denotes
that $e$ doesn't match $p$. Notably, we introduce the third possibility
$\hmaymatch{e}{p}$ --- $e$ may match $p$, which is also the \textit{key
concept} in pattern matching with holes. Rules \MMEHole and \MMHole specifies
that any final expression may match a pattern hole, regardless of whether it is
empty or non-empty. Rules \MMExpEHole and \MMExpHole specifies that an
expression hole, regardless of whether it is empty or non-empty, may match any
pattern except variable patterns and wild card patterns. It is because Rules
\MVar and \MWild specifies any final expression satisfies a variable pattern or
a wildcard pattern, and it does not make sense to allow
$\hpatmatch{e}{p}{\theta}$ and $\hmaymatch{e}{p}$ at the same time. Actually,
the three possible results of pattern matching are mutually exclusive and at
least one of judgment can be derived, which plays an important role in ensuring
\theoremname~\ref{thrm:determinism}.

\begin{lemma}[Matching Determinism]
  \label{lem:match-determinism}
  If $\isFinal{e}$ and $\hexptyp{\cdot}{\Delta}{e}{\tau}$ and $\hpattyp{p}{\tau}{\Gamma}{\Delta}$ then exactly one of the following holds
  \begin{enumerate}
    \item $\hpatmatch{e}{p}{\theta}$ for some $\theta$
    \item $\hmaymatch{e}{p}$
    \item $\hnotmatch{e}{p}$
  \end{enumerate}
\end{lemma}


\begin{theorem}[Determinism]
  \label{thrm:determinism}
  If $\hexptyp{\cdot}{\Delta}{e}{\tau}$ then exactly one of the following holds
  \begin{enumerate}
    \item $\isVal{e}$
    \item $\isIndet{e}$
    \item $\htrans{e}{e'}$ for some unique $e'$
  \end{enumerate}
\end{theorem}

\todo{State progress theorem instead of determinism or both?}

\begin{lemma}[Matching Progress]
  \label{lem:match-progress}
  If $\isFinal{e}$ and $\hexptyp{\cdot}{\Delta}{e}{\tau}$ and $\hpattyp{p}{\tau}{\Gamma}{\Delta'}$
  then $\hnotmatch{e}{p}$ or $\hmaymatch{e}{p}$ or $\hpatmatch{e}{p}{\theta}$ for some $\theta$
\end{lemma}

\begin{theorem}[Progress]
  \label{thrm:progress}
  If $\hexptyp{\cdot}{\Delta}{e}{\tau}$ then either $\isFinal{e}$ or $\htrans{e}{e'}$ for some $e'$.
\end{theorem}

\subsection{Static Semantics}\label{sec:statics}

We have already introduced how pattern matching with holes works in dynamic
semantics. However, in order to do exhaustiveness checking and redundancy
checking of match expressions in \listfigurename~\ref{fig:exh-hole},
\ref{fig:red-hole}, we need to predict the result of pattern matching in static
semantics. We start by introducing \textit{match constraint language}, which
extends the idea in \cite{Harper2012}. Then, we build a similar type system to
\cite{DBLP:journals/pacmpl/OmarVCH19} by defining typing judgments for both
patterns and expressions. The former generates variable contexts $\Gamma$ and
hole contexts $\Delta$ (see \figurename~\ref{fig:pattyp}) while the latter one
take variable contexts $\Gamma$ and hole contexts $\Delta$ as hypothesis (see
\figurename~\ref{fig:exptyp}).

\subsubsection{Match Constraint Language}\label{sec:constraint}
\input{fig-constraint}

\figurename~\ref{fig:constraint} gives the syntax of match constraint, which is
used to identify a subset of the final expressions of a type. The judgment
$\ctyp{\xi}{\tau}$ specifies that constraint $\xi$ constrains the final
expressions of type $\tau$. The dual of $\xi$, $\cdual{\xi}$ represents the
complement of the subset identified by $\xi$ under the set of the final
expressions of a type.

\subsubsection{Typing of Patterns}
\input{fig-pattyp}

\figurename~\ref{fig:pattyp} defines the typing judgment for patterns and
connects constraints with patterns. When pattern $p$ is assigned type $\tau$,
we collect the typing for the pattern variables and pattern holes in $p$ and
generate the corresponding variable context $\Gamma$ and hole context $\Delta$.
Besides two contexts, we emit a constraint $\xi$ to identify the set of final
expressions that match $p$. Rules \PTEHole and Rules \PTHole specifies that
pattern holes emits \textit{Unknown} constraint, $\cunknown$. That means, the
set of final expressions that matches the pattern is yet to be identified, we
will see how it is used in \figurename~\ref{fig:satisfy}.

\subsubsection{Satisfaction Judgments}
\input{fig-satisfy}

\figurename~\ref{fig:satisfy} defines satisfaction judgments.
\todo{satisfy and may satisfy}

\lemmaname~\ref{lem:const-matching-coherence} establishes a correspondence
between pattern matching results and satisfaction judgments. That makes
reasoning pattern matching in type system possible and helps prove
\theoremname~\ref{thrm:preservation}.

\begin{lemma}[Matching Coherence of Constraint]
  \label{lem:const-matching-coherence}
  Suppose that $\hexptyp{\cdot}{\Delta}{e}{\tau}$ and $\isFinal{e}$ and $\chpattyp{p}{\tau}{\xi}{\Gamma}{\Delta}$. Then we have
  \begin{enumerate}
  \item $\csatisfy{e}{\xi}$ iff $\hpatmatch{e}{p}{\theta}$
  \item $\csatisfy{e}{\cdual{\xi}}$ iff $\hnotmatch{e}{p}$
  \item $\cmaysatisfy{e}{\xi}$ iff $\hmaymatch{e}{p}$
  \end{enumerate}
\end{lemma}

The following two definitions take advantage satisfaction judgments and
corresponds to redundancy and exhaustiveness respectively. We will see how they
can be determined in Sec.~\ref{sec:algorithm}

\begin{definition}[Entailment of Constraints]
  \label{defn:const-entailment}
  Suppose that $\ctyp{\xi_1}{\tau}$ and $\ctyp{\xi_2}{\tau}$.
  Then $\csatisfy{\xi_1}{\xi_2}$ iff for all $e$ such that $\hexptyp{\cdot}{\Delta}{e}{\tau}$ and $\isFinal{e}$ we have $\csatisfyormay{e}{\xi_1}$ implies $\csatisfy{e}{\xi_2}$
\end{definition}

\begin{definition}[Not Not Entailment of Constraints]
  \label{defn:nn-entailment}
  Suppose that $\ctyp{\xi_1}{\tau}$ and $\ctyp{\xi_2}{\tau}$. Then $\csatisfyormay{\xi_1}{\xi_2}$ iff for all $e$ such that $\hexptyp{\cdot}{\Delta}{e}{\tau}$ and $\isFinal{e}$ we have $\csatisfyormay{e}{\xi_1}$ implies $\csatisfyormay{e}{\xi_2}$ 
\end{definition}

\subsubsection{Typing of Rules and Redundancy Checking}

\input{fig-ruletyp} 

\figurename~\ref{fig:ruletyp} defines the typing judgment of a rule. For a rule
$\hrul{p}{e}$, after generating the variable context and hole context from the
typing of $p$, we extend the variable context and the hole context of the rule
with the generated contexts and form the hypothesis for the typing of its
subexpression. Also, a rule inherits the constraint from its pattern.

\input{fig-rulestyp}

\figurename~\ref{fig:rulestyp} defines the typing judgment of a series of rules
that at least has one rule. Compared to a single rule, the form of the typing
judgment of rules is slightly different and involves two constraint components,
where $\xi_{pre}$ represent the constraints emitted from its preceding rules and
$\xi_{rs}$ represents the constraint emitted from the series of rules being type
checked. As we build up the rules, we check if the initial rule is redundant
with respect to its preceding rules, and the premise in both two Rules,
$\cnotsatisfy{\xi_r}{\xi_{pre}}$. It states that the judgment
$\csatisfy{\xi_r}{\xi_{pre}}$, which corresponds to redundancy, is not
derivable. In other words, rule $r$ either cannot be redundant or, may or may
not be redundant, with respect to it preceding rules. Rule \TOneRules specifies
that for \todo{single rules}, we can simply inherit $\xi_r$ emitted from typing
of $r$ and check the redundancy of $r$. Rule \TRules specifies that we collect
the $\xi_r$ and concatenate it with $\xi_{pre}$ as the new input to the typing
judgment of $rs$ and then wait for the output $\xi_rs$ and concatenate it with
$\xi_r$ to complete the conclusion.

\subsubsection{Typing of Expressions and Exhaustiveness Checking}

We have already shown how to collect constraints from rules in the typing
judgment of rules. Now we can use collected constraints to check exhaustiveness
in the typing judgment of match expressions.

\input{fig-exptyp}

\figurename~\ref{fig:exptyp} defines the typing judgment of expressions. Rule
\TMatchZPre corresponds to the case where we haven't started pattern matching.
As shown in \definitionname~\ref{defn:nn-entailment}, the premise
$\csatisfyormay{\ctruth}{\xi}$ ensures that there is at least one rule whose
pattern does match or may match the final scrutinee and thus the pattern
matching either results in a successful match (Rule \ITSuccMatch) or an
indeterminate match expression (Rule \IMatch). Rule \TMatchNZPre corresponds to
the case where we have already started pattern matching and thus the rule
pointer is not at the first rule. The premise $\cnotsatisfyormay{e}{\xi_{pre}}$
ensures that we have already considered the previous rules and none of them
either match or may match the final scrutinee. These two Rules specifies that
only when its constituent rules either must be exhaustive or may be exhaustive,
can the match expression be well-typed.

\theoremname~\ref{thrm:preservation} states that the typing of a expression is
preserved as we evaluate the expression. The correspondance between satisfaction
judgment and pattern matching plays an important role in ensuring the
preservation theorem.
 
\begin{theorem}[Preservation]
  \label{thrm:preservation}
  If $\hexptyp{\cdot}{\Delta}{e}{\tau}$ and $\htrans{e}{e'}$
  then $\hexptyp{\cdot}{\Delta}{e'}{\tau}$
\end{theorem}

\input{fig-substyp}

To prove \theoremname~\ref{thrm:progress}, we need the following lemmas.
\begin{lemma}[Substitution]
  \label{lem:substitution}
  If $\hexptyp{\Gamma, x : \tau}{\Delta}{e_0}{\tau_0}$ and $\hexptyp{\Gamma}{\Delta}{e}{\tau}$
  then $\hexptyp{\Gamma}{\Delta}{[e/x]e_0}{\tau_0}$
\end{lemma}

\begin{lemma}[Simultaneous Substitution]
  \label{lem:simult-substitution}
  If $\hexptyp{\Gamma \uplus \Gamma'}{\Delta}{e}{\tau}$ and $\hsubstyp{\theta}{\Gamma'}$
  then $\hexptyp{\Gamma}{\Delta}{[\theta]e}{\tau}$
\end{lemma}


\begin{lemma}[Substitution Typing]
  \label{lem:subs-typing}
  If $\hpatmatch{e}{p}{\theta}$ and $\hexptyp{\cdot}{\Delta}{e}{\tau}$ and $\hpattyp{p}{\tau}{\Gamma}{\Delta}$
  then $\hsubstyp{\theta}{\Gamma}$
\end{lemma}

\section{Algorithm}\label{sec:algorithm}

\section{Conclusion}
We can adapt our core calculus to fit in a more expressive setting.
\clearpage

\bibliographystyle{splncs04}
\bibliography{references.bib}
\end{document}
