\RequirePackage{etex}
\documentclass[runningheads,envcountsame,a4paper]{llncs}

\usepackage[T1]{fontenc} % fix missing font cmtt
\usepackage{amsmath}
\usepackage{amssymb} % Vdash
\usepackage{graphicx} % rotatebox
\usepackage{stmaryrd} % llparenthesis
\usepackage{anyfontsize} % workaround for font size difference warning
\usepackage{listings}
\usepackage{tikz}
\usetikzlibrary{calc,fit,tikzmark,plotmarks,arrows.meta,positioning,overlay-beamer-styles}
\usepackage[caption=false]{subfig}

\usepackage{cancel} % slash over symbol
\usepackage{hyperref}
\renewcommand\UrlFont{\color{blue}\rmfamily}

\usepackage{xcolor}
\definecolor{hazelgreen}{RGB}{7,63,36}
\definecolor{hazellightgreen}{RGB}{103,138,97}
\definecolor{hazelyellow}{RGB}{245,222,179}
\definecolor{hazellightyellow}{RGB}{254,254,234}

\newcommand{\highlight}[1]{\colorbox{yellow}{$\displaystyle #1$}}

\newcommand{\todo}[1]{{\color{red} TODO: #1}}

%% Joshua Dunfield macros
\def\OPTIONConf{1}
\usepackage{jdunfield}
\usepackage{rulelinks} % hyperlink of rule name
\usepackage{pfsteps}
\makeatletter
\newcommand{\savelocalsteps}[1]{
  \@ifundefined{c@#1}
    {% the counter doesn't exist
     \newcounter{#1}
   }{}
  \setcounter{#1}{\value{pfsteps@pfc@local}}
}
\makeatother
\newcommand{\restorelocalsteps}[1]{\setcounter{pfsteps@pfc@local}{\value{#1}}}

\input{macros}
\input{rulecommands}

\begin{document}
  
\title{Pattern Matching with Typed Holes}

\author{
  Yongwei Yuan\inst{1} \and 
}
\authorrunning{Y. Yuan et al.}
\institute{
  Purdue University, West Lafayette, USA \\
  \email{yuan311@purdue.edu} \and
  University of Michigan, Ann Arbor, USA
  \email{\{dmoo,hkpotter,wyuning,comar\}@umich.edu}}


\maketitle

\begin{abstract}
  The abstract should briefly summarize the contents of the paper in
  15--250 words.
  
  \keywords{live programming  \and typed holes \and contextual modal type theory.}
\end{abstract}

\section{Introduction}
\label{sec:intro}
Most contemporary programming environments either provide meaningful feedback only for complete programs, or fall back to limited heuristic approaches when the program is incomplete.
Recent work on modeling incomplete programs as typed expressions with \emph{holes} has focused on tackling this problem. \cite{DBLP:conf/popl/OmarVHAH17} describes a static semantics for incomplete functional programs. Based on that, \cite{DBLP:journals/pacmpl/OmarVCH19} develops a dynamic semantics to evaluate such incomplete programs.
These foundational treatments are being implemented and extended in the Hazel programming environment (hazel.org).

\emph{Pattern matching} is a cornerstone of functional programming languages in the ML family. 
However, \cite{DBLP:journals/pacmpl/OmarVCH19} only supports simple case analysis on binary sum types and does not support nested patterns nor pattern holes.
This paper addresses this problem, focusing on adding full ML-style pattern matching with support for pattern holes to the Hazelnut core calculus and implementing 
this system at full scale into Hazel. Consider the examples below, which contain expression and pattern holes, denoted $\hehole{u}$ (where each hole has a unique name, $u$). 

For the match expression shown in \Eqref{eq:complete}, the scrutinee contains a hole.
By considering the match two rules in order, we observe that
no matter how the hole $u$ is filled, $\hpair{\hinl{\tnum}{\hehole{u}}}{2}$ doesn't match $\hpair{\hinrp{x}}{\_}$,
and always matches $\hpair{\_}{x}$. And thus the value of the match expression is $2$, despite the fact that the program is incomplete.
If, however, we replaced the pattern in the first rule with $(\hinlp{3}, \_)$, it would be impossible to decide whether the pattern matches
or not, and so the match expression would be \emph{indeterminate}, i.e. awaiting hole filling.
%Similarly, if we had replaced the pattern in the first rule with $(\hinlp{x}, \hehole{w})$,
%then it is impossible to tell whether the pattern hole $w$ will match $2$ or not,
%so the match would also be indeterminate.

One of the benefits of pattern matching is that it allows for static reasoning about exhaustiveness and redundancy.
However, reasoning about these matters is subtle and complicated in the presence of holes. 
For example, consider the problem of checking if the rules in \Eqref{eq:pathole-exhaustive} cover all the possibilities, \ie \emph{exhaustiveness}, or if the second rule in \Eqref{eq:pathole-redundant} can never be reached no matter how the holes are filled, \ie \emph{redundancy}. 

This abstract focuses on the formalism of full-fledged pattern matching with typed holes so that the programming environment could give this sort of feedback even when considering incomplete match expressions.

\section{Live Pattern Matching}\label{sec:examples}

\begin{figure}[ht]
  \begin{tikzpicture}[remember picture, overlay]
    \node[rotate=-90,mark size=5pt,color=hazellightgreen,shift={(-0.1,-0.2)}] at (pic cs:exp-hole-1) {\pgfuseplotmark{triangle*}};
    \node[rotate=-90,mark size=5pt,color=hazellightgreen,shift={(-0.1,-0.2)}] at (pic cs:exp-hole-2) {\pgfuseplotmark{triangle*}};
  \end{tikzpicture}

  \centering
  \hspace*{\fill}%
  \captionsetup[subfloat]{labelformat=empty}
  \subfloat[]{%
    \makebox[\width]{
      $\begin{aligned}
        &\match (1::\?) \{ \\
        &\tikzmark{exp-hole-1}|~ \hrul{\nil}{\none} \\
        &|~ \hrul{x::xs}{\some{xs}} \\
        &\}
      \end{aligned}$
    }
  }%
  $\mapsto$
  \subfloat[]{
    \makebox[1.2\width]{
      $\begin{aligned}
        &\match (1::\?) \{ \\
        &|~ \hrul{\nil}{\none} \\
        &\tikzmark{exp-hole-2}|~ \hrul{1::xs}{\some{xs}} \\
        &\}
      \end{aligned}$
    }
  }%
  $\mapsto$
  \subfloat[]{
    $\some{?}$
  }
  \hspace*{\fill}%
  \caption{Pattern Matching with Expression Holes}
  \label{fig:exp-hole-step}
\end{figure}

\begin{figure}[ht]
  \begin{tikzpicture}[remember picture, overlay]
    \node[rotate=-90,mark size=5pt,color=hazellightgreen,shift={(-0.1,-0.2)}] at (pic cs:pat-hole-1) {\pgfuseplotmark{triangle*}};
    \node[rotate=-90,mark size=5pt,color=hazellightgreen,shift={(-0.1,-0.2)}] at (pic cs:pat-hole-2) {\pgfuseplotmark{triangle*}};
  \end{tikzpicture}

  \centering
  \hspace*{\fill}%
  \captionsetup[subfloat]{labelformat=empty}
  \subfloat[]{%
    \makebox[\width]{
      $\begin{aligned}
        &\match (1::\nil) \{ \\
        &\tikzmark{pat-hole-1}|~ \hrul{\nil}{\none} \\
        &|~ \hrul{\?::xs}{\some{xs}} \\
        &\}
      \end{aligned}$
    }
  }%
  $\mapsto$
  \subfloat[]{
    \makebox[1.2\width]{
      $\begin{aligned}
        &\match (1::\nil) \{ \\
        &|~ \hrul{\nil}{\none} \\
        &\tikzmark{pat-hole-2}|~ \hrul{\?::xs}{\some{xs}} \\
        &\}
      \end{aligned}$
    }
  }%
  $\not\mapsto$(indeterminate)
  \hspace*{\fill}%
  \caption{Pattern Matching with Pattern Holes}
  \label{fig:pat-hole-step}
\end{figure}

\begin{figure}[ht]
  \centering
  \hspace*{\fill}%
  \subfloat[May or may not be exhaustive.\label{fig:may-exhaustive}]{
    \makebox[2\width]{
      $\begin{aligned}
        &\match (1::\nil) \{ \\
        &|~ \hrul{\nil}{\none} \\
        &|~ \hrul{\?::xs}{\some{xs}} \\
        &\}
      \end{aligned}$
    }
  }%
  \hfill%
  \subfloat[Must not be exhaustive.\label{fig:not-exhasutive}]{
    \makebox[2\width]{
      $\begin{aligned}
        &\match (1::\nil) \{ \\
        &|~ \hrul{\nil}{\none} \\
        &|~ \hrul{1::\?}{\?} \\
        &\}
      \end{aligned}$
    }
  }%
  \hspace*{\fill}%
  \caption{Exhaustiveness Checking in Incomplete Match Expressions}
  \label{fig:exh-hole}
\end{figure}

\begin{figure}[ht]
  \centering
  \hspace*{\fill}%
  \subfloat[May or may not be redundant.\label{fig:may-redundant1}]{
    \makebox[0.8\width]{
      $\begin{aligned}
        &\match (1::2::\nil) \{ \\
        &|~ \hrul{\nil}{\none} \\
        &|~ \hrul{x::\?}{\?} \\
        &|~ \hrul{1::xs}{\some{xs}} \\
        &\}
      \end{aligned}$
    }
  }%
  \hfill%
  \subfloat[May or may not be redundant.\label{fig:may-redundant2}]{
    \makebox[0.8\width]{
      $\begin{aligned}
        &\match (1::2::\nil) \{ \\
        &|~ \hrul{\nil}{\none} \\
        &|~ \hrul{x::\?}{\?} \\
        &|~ \hrul{1::2::\nil}{\some{2:\nil}} \\
        &\}
      \end{aligned}$
    }
  }%
  \hfill%
  \subfloat[Must be redundant.\label{fig:redundant}]{
    \makebox[0.7\width]{
      $\begin{aligned}
        &\match (1::2::\nil) \{ \\
        &|~ \hrul{\nil}{\none} \\
        &|~ \hrul{x::xs}{\some{xs}} \\
        &|~ \hrul{\?::xs}{\some{xs}} \\
        &\}
      \end{aligned}$
    }
  }%
  \hspace*{\fill}%
  \caption{Redundancy Checking in Incomplete Match Expressions}
  \label{fig:red-hole}
\end{figure}

\section{The Core Calculus}
With the intuition developed in the previous section, we can formally specify
what we mean by pattern matching with holes and also build the type system to
give eager feedback while the user is programming.

\input{fig-syntax}

\paragraph{Overview.}
We will first go over the syntax of the core calculus. Then we will describe the dynamic
semantics including the judgment $\isFinal{e}$ and the stepping judgment
$\htrans{e}{e'}$. Motivated by the dynamic semantics, we define the static
semantics, including the typing judgment for
rules $\chrulstyp{\Gamma}{\Delta}{\xi_{pre}}{rs}{\tau_1}{\xi_{rs}}{\tau_2}$, a
single rule $\chrultyp{\Gamma}{\Delta}{\hrulP{p}{e}}{\tau_1}{\xi}{\tau_2}$, and
pattern $\chpattyp{p}{\tau}{\xi}{\Gamma}{\Delta}$. At last, we introduce match constraint
language and its semantics, which connects the dynamics and the statics.

\subsection{Syntax}
The syntax of the core calculus is given in \figurename~\ref{fig:syntax}. To
balance simplicity and power of pattern matching with holes, we use number as
the base type and include function type, product type, and sum type in the
calculus. For each type, there are corresponding expression(s) serving as the
introduction form and elimination form of the type. Besides, holes, as missing
parts in a program, can be of any type (see Sec.~\ref{sec:statics}). And the
most interesting part is the syntax of match expressions. A match expression
consists of an expression, called scrutinee, and zipper rules \todo{ref}. Zipper
rules denotes a series of rules with a pointer on the current rule being
considered in runtime (see Sec.~\ref{sec:dynamics}). As in other ML languages,
each rule consists of a pattern and an expression \todo{ref}. And just like
expressions, patterns may also involve holes and are assigned corresponding
types (see Sec.~\ref{sec:statics}).

\subsection{Dynamic Semantics}\label{sec:dynamics}
Pattern matching happens during runtime and the dynamic semantics motivates the
design of the static semantics in Sec.~\ref{sec:statics}. And thus, we start by
taking a step further from the examples shown in
\listfigurename~\ref{fig:exp-hole-step},\ref{fig:pat-hole-step}, and formalize
the described heuristic.

\input{fig-pointer-eraser}
\input{fig-step}

In Sec.~\ref{sec:examples}, we use a rule pointer to simulate the process in
which we consider the rules in order. Correspondingly, in the syntax of the core
calculus, we use zipper rules of the form $\zrulsP{rs}{r}{rs}$ in match
expressions to represent the intermediate states when we are performing pattern
matching. The former $rs$ represents the preceding rules that has already been
considered and fails to match the scrutinee; the rule $r$ in the middle
represents the current rule being considered; the latter $rs$ represents the
remaining rules to be considered. \figurename~\ref{fig:pointer-eraser} defines a
helper function to flatten the zipper rules. If we need to move the rule pointer
to the next rule, we can append the current rule after the preceding rules, and
regard the initial rule in the remaining rule as the new current rule. The
conclusion of Rule \ITFailMatch demonstrates how it works.

\input{fig-final}

\figurename~\ref{fig:step} defines the stepping judgment
$\htrans{e}{e'}$. We will focus on stepping judgments of match expressions.
Rule \ITExpMatch specifies that the match expression can take a step as its its
scrutinee can take a step. Note that Rule \ITFailMatch and Rule \ITSuccMatch
share the premise, $\isFinal{e}$, which is defined in \figurename~\ref{fig:final}. It
means that expression $e$ is \textit{final} in the sense that it is either already a
\textit{value} or \textit{indeterminate}, \ie, cannot be evaluated further due to unfilled holes
\cite{DBLP:journals/pacmpl/OmarVCH19}. And only when the scrutinee is final,
shall we consider the constinuent rules of the match expression in order. As in
the examples shown in \listfigurename~\ref{fig:exp-hole-step},\ref{fig:pat-hole-step},

\begin{itemize}
  \item
    if the final scrutinee does not match the pattern in the current rule,
    then we move the pointer to the next rule (Rule \ITFailMatch)

  \item
    if the final scrutinee does match the pattern in the current rule, 
    then we take the emitted substitution $\theta$ and apply it on the subexpression of that rule (Rule \ITSuccMatch)

  \item 
    if the final scrutinee may or may not match the pattern in the current rule,
    then the match expression is said to be indeterminate (Rule \IMatch)
\end{itemize}

\input{fig-patmatch}
\input{fig-refutable}

\figurename~\ref{fig:patmatch} defines three judgments corresponding to the
three possible results of pattern matching. We consider a final scrutinee $e$
and a pattern $p$ that are of the same type (see Sec.~\ref{sec:statics}). The
judgment $\hpatmatch{e}{p}{\theta}$ denotes that $e$ matches $p$, as witness by
the substitution $\theta$ defined on the variables in $p$, while the judgment
$\hnotmatch{e}{p}$ denotes that $e$ doesn't match $p$. Notably, we introduce the
third possibility $\hmaymatch{e}{p}$ --- $e$ may match $p$, which is also the
\textit{key concept} in pattern matching with holes. Rules \MMEHole and \MMHole
specifies that any final expression may match a pattern hole, regardless of
whether it is empty or non-empty. On the other hand, only when pattern $p$ is
refutable (see \figurename~\ref{fig:refutable}), can we say that an indeterminate
expression may or may not match the pattern. It is because any final expressions
must match an irrefutable pattern of the same type, and it does not make sense to allow
$\hpatmatch{e}{p}{\theta}$ and $\hmaymatch{e}{p}$ to be derivable at the same time. Actually,
the three possible results of pattern matching are mutually exclusive and at
least one of judgments can be derived under certain assumptions, as shown in the
following lemma.

\begin{lemma}[Matching Determinism]
  \label{lem:match-determinism}
  If $\isFinal{e}$ and $\hexptyp{\cdot}{\Delta}{e}{\tau}$ and $\hpattyp{p}{\tau}{\Gamma}{\Delta}$ then exactly one of the following holds
  \begin{enumerate}
    \item $\hpatmatch{e}{p}{\theta}$ for some $\theta$
    \item $\hmaymatch{e}{p}$
    \item $\hnotmatch{e}{p}$
  \end{enumerate}
\end{lemma}

The determinism of pattern matching ensures the determinism of dynamic semantics.

\begin{theorem}[Determinism]
  \label{thrm:determinism}
  If $\hexptyp{\cdot}{\Delta}{e}{\tau}$ then exactly one of the following holds
  \begin{enumerate}
    \item $\isVal{e}$
    \item $\isIndet{e}$
    \item $\htrans{e}{e'}$ for some unique $e'$
  \end{enumerate}
\end{theorem}

\subsection{Static Semantics}\label{sec:statics}

We have already introduced how pattern matching with holes works. Now, we want
to predict the runtime behavior of match expressions through checking
exhaustiveness and redundancy in static semantics. However, in order to do exhaustiveness checking and redundancy
checking of match expressions in \listfigurename~\ref{fig:exh-hole},
\ref{fig:red-hole}, we need to predict the result of pattern matching in static
semantics. We start by introducing \textit{match constraint language}, which
extends the idea in \cite{Harper2012}. Then, we build a similar type system to
\cite{DBLP:journals/pacmpl/OmarVCH19} by defining typing judgments for both
patterns and expressions. The former generates variable contexts $\Gamma$ and
hole contexts $\Delta$ (see \figurename~\ref{fig:pat-rulestyp}) while the latter 
takes variable contexts $\Gamma$ and hole contexts $\Delta$ as hypothesis (see
\figurename~\ref{fig:exptyp}).

\subsubsection{Typing of Expressions and Exhaustiveness Checking} \label{sec:exptyp}

We start by specifying the typing of expressions, particularly, match
expressions. And we will see that the definition of the typing judgments of
match expressions enforce exhaustiveness of the constituent rules.
\figurename~\ref{fig:exptyp} defines the typing judgment of expressions.

\input{fig-exptyp}

Rule \TMatchZPre corresponds to the case that we have not started pattern
matching. The first premise specifies that the scrutinee $e$ is of type $\tau$,
and the second premise specifies that the constituent rules $\hrul{r}{rs}$ are not only
well-typed but also transforms a final expression of the same type as the
scrutinee, into a final expression of type $\tau'$. Notably, it generates a
constraint $\xi$ associated with the constituent rules $rs$. Then we use the
third premise $\csatisfyormay{\ctruth}{\xi}$ to ensure that there is at least
one rule whose pattern does match or may match the final scrutinee (see
Sec.~\ref{sec:constraint}). In other words, for a well-typed match expression,
it is impossible that the final scrutinee fails to match all the patterns as we
consider rules $rs$ in order.

Rule \TMatchNZPre corresponds to the case that we have already started pattern
matching and have already considered preceding rules $rs_{pre}$. First of all,
the scrutinee should not only be well-typed but also be final. Next, other than
ensuring the exhaustiveness of the constituent rules, we want to make sure that
at least one of the remaining rules $r_{post}$ would be taken. Note
that only when the final scrutinee $e$ cannot match the pattern $p$, \ie,
$\hnotmatch{e}{p}$, can we move the rule pointer. By
\lemmaname~\ref{lem:match-determinism}, for all patterns $p$ in the preceding
rules, neither $\hpatmatch{e}{p}{\theta}$ nor $\hmaymatch{e}{p}$ is derivable.
Then by \lemmaname~\ref{lem:const-matching-coherence}, we can derive the premise
in Rule \TMatchNZPre, $\cnotsatisfyormay{e}{\xi_{pre}}$. And thus, the type of
the match expression is preserved (\theoremname~\ref{thrm:preservation})as we consider rules in order.

\subsubsection{Typing of Patterns and Rules, and Redundancy Checking}

\input{fig-pat-rulestyp}

\figurename~\ref{fig:pat-rulestyp} defines the typing judgment for patterns $p$,
single rules $r$, and series of rules $rs$. We will see how constraint $\xi$ is
generated, accumulated, and used to check redundancy of a rule $r$ with respect
to its preceding ones.

The typing judgment of series of rules $rs$ is of the form
$\chrulstyp{\Gamma}{\Delta}{\xi_{pre}}{rs}{\tau_1}{\xi_{rs}}{\tau_2}$. As shown
in Rules \TMatchZPre and \TMatchNZPre, the constituent rules inherit the
variable context $\Gamma$ and hole context $\Delta$ from the outer match
expression. When we check the type of a series of rules, we consider each rule
in order, just as how we do pattern matching in Sec.~\ref{sec:dynamics}.

Rule \TRules corresponds to the inductive case. The first premise is to check
the type of the initial rule $r$. It specifies that each rule takes a final expression
of type $\tau_1$ and returns a final expression of type $\tau_2$. It also emits
a constraint $\xi_r$, which is actually emitted from the pattern of rule $r$ as
we will see later. In order to determine if the initial rule $r$ of the rules
$\hrules{r}{rs}$ is redundant with respect to its preceding rules, we use
$\xi_{pre}$ to keep track of the pattern matching information of preceding
rules. To accomplish that, as we drop the initial rule $r$, we append the
constraint $\xi_r$ emitted from the pattern of $r$, to the constraint
$\xi_{pre}$, and use $\cor{\xi_{pre}}{\xi_r}$ as the new input to inductively check the type
of the trailing rules $rs$ in the second premise. Now that we have shown how to maintain the
constraint $\xi_{pre}$ associated with the preceding rules, we can compare it
with the constraint of the current rule, $\xi_r$. As we check the
type of rules, we consider each rule in order and use
$\cnotsatisfy{\xi_r}{\xi_{pre}}$ to ensure that the current rule $r$ doesn't
have to be redundant with respect to its preceding rules. We will see in
Sec.~\ref{sec:constraint} that $\csatisfy{\xi_r}{\xi_{pre}}$ corresponds to
``must redundant''. At the same time, the judgment also outputs the accumulated
constraint collected from rules $\hrules{r}{rs}$, which is used to check
exhaustiveness of rules, as we have shown in Sec.~\ref{sec:exptyp}

Rule \TOneRules corresponds to the base case that the series of rules contains
only one rule. The premises are similar to that of Rule \TRules except that
there is no trailing rules to check the type of. The reason why we regard one
rule as the base case instead of empty rules, is that since our match expression
takes zipper rules, we will never need to check the type of empty rules. The
only case that it makes sense to allow a match expression to contain empty
rules, is when we match on a final expression of \textit{Void} type and thus
don't need to worry about exhaustiveness checking. It turns out that we do not
have to sacrifice the generality (see Appendix \todo{match(){.}}).

As we have briefly mentioned above, Rule \TRule specifies that rule
$\hrul{p}{e}$ transforms final expressions of type $\tau_1$ to final expressions
of type $\tau_2$. The first premise is the typing judgment of patterns---by
assigning pattern $p$ with type $\tau_1$, we collect the typing for all the
variables and holes involved in the pattern $p$ and generate variable context
$\Gamma_p$ and hole context $\Delta_p$. Additionally, it emits constraint $\xi$,
which is closely associated with the pattern itself. While constraint is used to
identify the set of final expressions that match $p$, we introduce
\textit{Unknown} constraint $\cunknown$ to denote the set of final expression
matching $p$ is yet to be determined (Rules \PTEHole and \PTHole). We will elaborate on what constraint is in
Sec.~\ref{sec:constraint}. The second premise strictly extends two contexts of
rule $r$ with that generated from pattern $p$, and check the type of
sub-expression $e$.

\subsubsection{Type Safety}
The type safety of the language is established by
\theoremname~\ref{thrm:determinism} and \theoremname~\ref{thrm:preservation}.

\begin{theorem}[Preservation]
  \label{thrm:preservation}
  If $\hexptyp{\cdot}{\Delta}{e}{\tau}$ and $\htrans{e}{e'}$
  then $\hexptyp{\cdot}{\Delta}{e'}{\tau}$
\end{theorem}

\input{fig-substyp}

\figurename~\ref{fig:substyp} defines the typing of substitution $\theta$.

To prove \theoremname~\ref{thrm:preservation}, we need the following three lemmas.
When considering Rule \ITAp, \lemmaname~\ref{lem:substitution} is needed.
When considering Rule \ITSuccMatch, \lemmaname~\ref{lem:subs-typing} is needed
to show the typing of substitution $\theta$, and we use
\lemmaname~\ref{lem:simult-substitution} to show that type is preserved when pattern
matching succeeds.

\begin{lemma}[Substitution]
  \label{lem:substitution}
  If $\hexptyp{\Gamma, x : \tau}{\Delta}{e_0}{\tau_0}$ and $\hexptyp{\Gamma}{\Delta}{e}{\tau}$
  then $\hexptyp{\Gamma}{\Delta}{[e/x]e_0}{\tau_0}$
\end{lemma}

\begin{lemma}[Substitution Typing]
  \label{lem:subs-typing}
  If $\hpatmatch{e}{p}{\theta}$ and $\hexptyp{\cdot}{\Delta}{e}{\tau}$ and $\hpattyp{p}{\tau}{\Gamma}{\Delta'}$
  then $\hsubstyp{\theta}{\Gamma}$
\end{lemma}

\begin{lemma}[Simultaneous Substitution]
  \label{lem:simult-substitution}
  If $\hexptyp{\Gamma \uplus \Gamma'}{\Delta}{e}{\tau}$ and $\hsubstyp{\theta}{\Gamma'}$
  then $\hexptyp{\Gamma}{\Delta}{[\theta]e}{\tau}$
\end{lemma}

\subsubsection{Match Constraint Language}\label{sec:constraint}
\input{fig-constraint}

\figurename~\ref{fig:constraint} introduces match constraint language, which is
used to identify a subset of the final expressions of a type. The judgment
$\ctyp{\xi}{\tau}$ specifies that constraint $\xi$ constrains the final
expressions of type $\tau$. The dual of $\xi$, $\cdual{\xi}$ represents the
complement of the subset identified by $\xi$ under the set of the final
expressions of a type.

\input{fig-satisfy}

\figurename~\ref{fig:satisfy} defines satisfaction judgments. As we only
consider final expressions and patterns of the same type when talking about
pattern matching, a constraint only constrains final expressions of the same
type. And the satisfaction judgments does not make sense when the expression is
not final or the expression and the constraint are of different type. The
judgment $\csatisfy{e}{\xi}$ specifies that expression $e$ satisfies $\xi$ while
the judgment $\cmaysatisfy{e}{\xi}$ specifies that expression $e$ may or may not
satisfy $\xi$. The judgment $\csatisfyormay{e}{\xi}$ is the combination of the
previous two cases. It turns out that the remaining case where
$\csatisfyormay{e}{\xi}$ is not derivable, can be represented by
$\csatisfy{e}{\cdual{\xi}}$.

\begin{theorem}[Exclusiveness of Constraint Satisfaction]
  \label{thrm:exclusive-constraint-satisfaction}
  If $\ctyp{\xi}{\tau}$ and $\hexptyp{\cdot}{\Delta}{e}{\tau}$ and $\isFinal{e}$ then exactly one of the following holds
  \begin{enumerate}
  \item $\csatisfy{e}{\xi}$
  \item $\cmaysatisfy{e}{\xi}$
  \item $\csatisfy{e}{\cdual{\xi}}$
  \end{enumerate}
\end{theorem}

\lemmaname~\ref{lem:const-matching-coherence} establishes a correspondence
between pattern matching results and satisfaction judgments. That makes
reasoning pattern matching in type system possible and helps prove
\theoremname~\ref{thrm:preservation}.

\begin{lemma}[Matching Coherence of Constraint]
  \label{lem:const-matching-coherence}
  Suppose that $\hexptyp{\cdot}{\Delta}{e}{\tau}$ and $\isFinal{e}$ and $\chpattyp{p}{\tau}{\xi}{\Gamma}{\Delta}$. Then we have
  \begin{enumerate}
  \item $\csatisfy{e}{\xi}$ iff $\hpatmatch{e}{p}{\theta}$
  \item $\csatisfy{e}{\cdual{\xi}}$ iff $\hnotmatch{e}{p}$
  \item $\cmaysatisfy{e}{\xi}$ iff $\hmaymatch{e}{p}$
  \end{enumerate}
\end{lemma}

The following two definitions take advantage satisfaction judgments and
corresponds to redundancy and exhaustiveness respectively. We will see how they
can be determined in Sec.~\ref{sec:algorithm}

\begin{definition}[Entailment of Constraints]
  \label{defn:const-entailment}
  Suppose that $\ctyp{\xi_1}{\tau}$ and $\ctyp{\xi_2}{\tau}$.
  Then $\csatisfy{\xi_1}{\xi_2}$ iff for all $e$ such that $\hexptyp{\cdot}{\Delta}{e}{\tau}$ and $\isVal{e}$ we have $\csatisfyormay{e}{\xi_1}$ implies $\csatisfy{e}{\xi_2}$
\end{definition}

Recall in Rules \TOneRules and \TRules, we use $\cnotsatisfy{\xi_r}{\xi_{pre}}$ to ensure rule $r$ does not have to be redundant with respect to its preceding rules $rs_{pre}$. When considering the redundancy of a specific rule in a match expression, the programmer only want to be warned when the rule is destined be redundant, regardless of how the programmer fills the holes at the end. Therefore, only when all values that must or may match the pattern of rule $r$, must have already matched one of the patterns in its preceding rules $rs_{pre}$, can we say $r$ must be redundant with respect to $rs_{pre}$.

\begin{definition}[Not Not Entailment of Constraints]
  \label{defn:nn-entailment}
  Suppose that $\ctyp{\xi_1}{\tau}$ and $\ctyp{\xi_2}{\tau}$. Then $\csatisfyormay{\xi_1}{\xi_2}$ iff for all $e$ such that $\hexptyp{\cdot}{\Delta}{e}{\tau}$ and $\isFinal{e}$ we have $\csatisfyormay{e}{\xi_1}$ implies $\csatisfyormay{e}{\xi_2}$ 
\end{definition}

Recall in Rules \TMatchZPre and \TMatchNZPre, we use $\csatisfyormay{\ctruth}{\xi}$ to ensure that the rules associated with constraint $\xi$ either must or may be exhaustive. When considering the exhaustiveness of a sequence of rules, the programmer only want to be warned when the rules cannot be exhaustive, regardless of how the programmer fills the holes at the end. Then, we just need to ensure that for all values $e$, $e$ either must or may match one of the patterns in the sequence of the rules. For simplicity when proving the progress part of  \theoremname~\ref{thrm:determinism}, we consider all final expressions instead. In this way, even when the match expression is not complete and we may match on an indeterminate expression, we can still be confident that we won't have a match failure error. And actually, as we will later show in Sec.~\ref{sec:algorithm}, it is legitimate to replace values with final expressions in the quantifier.

\section{De-unknown}\label{sec:algorithm}

We have already shown in Sec.~\ref{sec:statics} how to check redundancy and
exhaustiveness using \definitionname~\ref{defn:const-entailment} and
\definitionname~\ref{defn:nn-entailment}, but it remains unclear how to
determine whether they are true or false.

\input{fig-truify-falsify}

\figurename~\ref{fig:truify-falsify} defines function \textit{truify} and \textit{falsify},
which substitute unknown constraint with truth constraint $\ctruth$ and falsity
constraint $\cfalsity$ respectively. That mechanism turns to actually closely follow us, as human, as for how to determine exhaustiveness and redundancy when it comes to incomplete match expression.

Consider the examples in \figurename~\ref{fig:exh-hole}, to make it exhaustive, we would naturally replace pattern hole $w$ with a variable pattern or a wild card pattern. Since the Unknown constraint $\cunknown$ is directly emitted from the pattern hole $w$, analogously, we replace it with Truth constraint $\ctruth$.
\begin{theorem}
  $\csatisfyormay{\ctruth}{\xi}$ iff $\csatisfy{\ctruth}{\ctruify{\xi}}$.
\end{theorem}

\begin{lemma}
  $\csatisfyormay{e}{\xi}$ iff $\csatisfyormay{e}{\ctruify{\xi}}$.
\end{lemma}

\begin{lemma}
  Assume $\ctruify{\xi}=\xi$. Then $\csatisfyormay{\ctruth}{\xi}$ iff $\csatisfy{\ctruth}{\xi}$.
\end{lemma}

Consider the example in \figurename~\ref{fig:redundant}, we want to tell if the third rule is redundant with respect to the first and second rules. To maximize the subset of values of list type that matches the pattern $\hehole{w}::xs$, we again replace the pattern hole $w$ with a variable pattern or a wild card pattern and realize that it is redundant. When there are hole(s) in the patterns of preceding rules, it is not obvious what pattern to replace the hole with. Consider the example in \figurename~\ref{fig:may-redundant1}, we want to tell if the third rule is redundant. To accomplish that, we want to minimize the subset of values of list type that matches $x::\hehole{w}$ so that it does not cover all the cases of the last branch. Intuitively, we may fill hole $\hehole{w}$ with $2::\nil$ so that the trailing part of the second pattern is more specific than $xs$ in the third pattern. However, it is not always the case that we can find a more specific (sub)pattern. Consider the example in \figurename~\ref{fig:may-redundant2}, the third pattern only matches one values and thus we cannot find a more specific pattern. Particularly, $2::\nil$ in the third pattern corresponds to the hole pattern $\hehole{w}$ in the second pattern. In this case, we can always find a different pattern to substitute the hole pattern. For example, we can replace $\hehole{w}$ with $3::[]$ and find that the third rule is not redundant.
\begin{theorem}
  $\csatisfy{\xi_r}{\xi_{rs}}$ iff $\csatisfy{\ctruth}{\cor{\cdual{\ctruify{\xi_r}}}{\cfalsify{\xi_{rs}}}}$.
\end{theorem}

\begin{lemma}
  Assume $\isVal{e}$. Then $\csatisfyormay{e}{\xi}$ iff $\csatisfy{e}{\ctruify{\xi}}$.
\end{lemma}

\begin{lemma}
  $\csatisfy{e}{\xi}$ iff $\csatisfy{e}{\cfalsify{\xi}}$.
\end{lemma}

\begin{lemma}
  Assume $\isVal{e}$ and $\ctruify{\xi}=\xi$. Then $\cnotsatisfy{e}{\xi}$ iff $\csatisfy{e}{\cdual{\xi}}$.
\end{lemma}

The reason why we can always find a different pattern is because we have number as the base type of our language. What if we add unit type? (We actually need unit type to represent empty list!) Then we no longer have infinite patterns that is of arbitrary given type. We can simply emit Truth constraint $\ctruth$ when assigning unit type to pattern holes (see Appendix \todo{}).

\figurename~\ref{fig:incon} defines \textit{inconsistent} judgment to further determine $\csatisfy{\ctruth}{\xi}$. Note that at this stage, constraint $\xi$ does not involve any Unknown constraint $\cunknown$. The inconsistent judgment $\cincon{\xi}$ specifies that constraint $\xi$ is inconsistent in the sense that no value of the same type as $\xi$ satisfies $\xi$.

\input{fig-incon}

\begin{theorem}
  Assume $\ctruify{\xi}=\xi$. It is decidable whether $\cincon{\xi}$.
\end{theorem}

\begin{theorem}
  Assume $\ctruify{\xi}=\xi$. Then $\cincon{\cdual{\xi}}$ iff $\csatisfy{\ctruth}{\xi}$.
\end{theorem}

\section{Conclusion}
We can adapt our core calculus to fit in a more expressive setting.
\clearpage

\bibliographystyle{splncs04}
\bibliography{references.bib}

\appendix
\section{Statics}
\end{document}
