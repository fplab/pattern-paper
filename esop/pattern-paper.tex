\RequirePackage{etex}
\documentclass[runningheads,envcountsame,a4paper]{llncs}

\usepackage[T1]{fontenc} % fix missing font cmtt
\usepackage{amsmath}
\usepackage{amssymb} % Vdash
\usepackage{graphicx} % rotatebox
\usepackage{stmaryrd} % llparenthesis
\usepackage{anyfontsize} % workaround for font size difference warning
\usepackage{listings}
\usepackage{tikz}
\usetikzlibrary{calc,fit,tikzmark,plotmarks,arrows.meta,positioning,overlay-beamer-styles}
\usepackage[caption=false]{subfig}

\usepackage{cancel} % slash over symbol
\usepackage{hyperref}
\renewcommand\UrlFont{\color{blue}\rmfamily}

\usepackage{xcolor}
\definecolor{hazelgreen}{RGB}{7,63,36}
\definecolor{hazellightgreen}{RGB}{103,138,97}
\definecolor{hazelyellow}{RGB}{245,222,179}
\definecolor{hazellightyellow}{RGB}{254,254,234}

\newcommand{\highlight}[1]{\colorbox{yellow}{$\displaystyle #1$}}

\newcommand{\todo}[1]{{\color{red} TODO: #1}}

%% Joshua Dunfield macros
\def\OPTIONConf{1}
\usepackage{jdunfield}
\usepackage{rulelinks} % hyperlink of rule name
\input{macros}
\input{rulecommands}

\begin{document}
  
\title{Pattern Matching with Typed Holes}

\author{
  Yongwei Yuan\inst{1} \and 
}
\authorrunning{Y. Yuan et al.}
\institute{
  Purdue University, West Lafayette, USA \\
  \email{yuan311@purdue.edu} \and
  University of Michigan, Ann Arbor, USA
  \email{\{dmoo,hkpotter,wyuning,comar\}@umich.edu}}


\maketitle

\begin{abstract}
  The abstract should briefly summarize the contents of the paper in
  15--250 words.
  
  \keywords{live programming  \and typed holes \and contextual modal type theory.}
\end{abstract}

\section{Introduction}
\label{sec:intro}
Most contemporary programming environments either provide meaningful feedback only for complete programs, or fall back to limited heuristic approaches when the program is incomplete.
Recent work on modeling incomplete programs as typed expressions with \emph{holes} has focused on tackling this problem. \cite{DBLP:conf/popl/OmarVHAH17} describes a static semantics for incomplete functional programs. Based on that, \cite{DBLP:journals/pacmpl/OmarVCH19} develops a dynamic semantics to evaluate such incomplete programs.
These foundational treatments are being implemented and extended in the Hazel programming environment (hazel.org).

\emph{Pattern matching} is a cornerstone of functional programming languages in the ML family. 
However, \cite{DBLP:journals/pacmpl/OmarVCH19} only supports simple case analysis on binary sum types and does not support nested patterns nor pattern holes.
This paper addresses this problem, focusing on adding full ML-style pattern matching with support for pattern holes to the Hazelnut core calculus and implementing 
this system at full scale into Hazel. Consider the examples below, which contain expression and pattern holes, denoted $\hehole{u}$ (where each hole has a unique name, $u$). 

For the match expression shown in \Eqref{eq:complete}, the scrutinee contains a hole.
By considering the match two rules in order, we observe that
no matter how the hole $u$ is filled, $\hpair{\hinl{\tnum}{\hehole{u}}}{2}$ doesn't match $\hpair{\hinrp{x}}{\_}$,
and always matches $\hpair{\_}{x}$. And thus the value of the match expression is $2$, despite the fact that the program is incomplete.
If, however, we replaced the pattern in the first rule with $(\hinlp{3}, \_)$, it would be impossible to decide whether the pattern matches
or not, and so the match expression would be \emph{indeterminate}, i.e. awaiting hole filling.
%Similarly, if we had replaced the pattern in the first rule with $(\hinlp{x}, \hehole{w})$,
%then it is impossible to tell whether the pattern hole $w$ will match $2$ or not,
%so the match would also be indeterminate.

One of the benefits of pattern matching is that it allows for static reasoning about exhaustiveness and redundancy.
However, reasoning about these matters is subtle and complicated in the presence of holes. 
For example, consider the problem of checking if the rules in \Eqref{eq:pathole-exhaustive} cover all the possibilities, \ie \emph{exhaustiveness}, or if the second rule in \Eqref{eq:pathole-redundant} can never be reached no matter how the holes are filled, \ie \emph{redundancy}. 

This abstract focuses on the formalism of full-fledged pattern matching with typed holes so that the programming environment could give this sort of feedback even when considering incomplete match expressions.

\section{Live Pattern Matching}

\begin{figure}[ht]
  \centering
  \hspace*{\fill}%
  \subfloat[Incomplete scrutinee\label{fig:scrut-hole}]{%
    \makebox[1.6\width]{
      $\begin{aligned}
        &\match (1::\?) \{ \\
        &|~ \hrul{\nil}{\text{`first rule'}} \\
        &|~ \hrul{1::xs}{\text{`second rule'}} \\
        &|~ \hrul{2::xs}{\text{`third rule'}} \\
        &\}
      \end{aligned}$
    }
  }%
  \hfill%
  \subfloat[Incomplete pattern\label{fig:pat-hole}]{
    \makebox[1.3\width]{
      $\begin{aligned}
        &\match (1::\nil) \{ \\
        &|~ \hrul{\nil}{\text{`first rule'}} \\
        &|~ \hrul{\?::xs}{\text{`second rule'}} \\
        &|~ \hrul{2::xs}{\text{`third rule'}} \\
        &\}
      \end{aligned}$
    }
  }%
  \hspace*{\fill}%
  \caption{Incomplete Match Expressions}
  \label{fig:exp-pat-hole}
\end{figure}

\begin{figure}[ht]
  \begin{tikzpicture}[remember picture, overlay]
    \node[rotate=-90,mark size=5pt,color=hazellightgreen,shift={(-0.1,-0.2)}] at (pic cs:exp-hole-1) {\pgfuseplotmark{triangle*}};
    \node[rotate=-90,mark size=5pt,color=hazellightgreen,shift={(-0.1,-0.2)}] at (pic cs:exp-hole-2) {\pgfuseplotmark{triangle*}};
  \end{tikzpicture}

  \centering
  \hspace*{\fill}%
  \captionsetup[subfloat]{labelformat=empty}
  \subfloat[]{%
    \makebox[\width]{
      $\begin{aligned}
        &\match (1::\?) \{ \\
        &\tikzmark{exp-hole-1}|~ \hrul{\nil}{\text{`first rule'}} \\
        &|~ \hrul{1::xs}{\text{`second rule'}} \\
        &|~ \hrul{2::xs}{\text{`third rule'}} \\
        &\}
      \end{aligned}$
    }
  }%
  $\rightarrow$
  \subfloat[]{
    \makebox[1.2\width]{
      $\begin{aligned}
        &\match (1::\?) \{ \\
        &|~ \hrul{\nil}{\text{`first rule'}} \\
        &\tikzmark{exp-hole-2}|~ \hrul{1::xs}{\text{`second rule'}} \\
        &|~ \hrul{2::xs}{\text{`third rule'}} \\
        &\}
      \end{aligned}$
    }
  }%
  $\rightarrow$
  \subfloat[]{
    `second rule'
  }
  \hspace*{\fill}%
  \caption{Pattern Matching with Expression Holes}
  \label{fig:exp-hole-step}
\end{figure}

\begin{figure}[ht]
  \begin{tikzpicture}[remember picture, overlay]
    \node[rotate=-90,mark size=5pt,color=hazellightgreen,shift={(-0.1,-0.2)}] at (pic cs:pat-hole-1) {\pgfuseplotmark{triangle*}};
    \node[rotate=-90,mark size=5pt,color=hazellightgreen,shift={(-0.1,-0.2)}] at (pic cs:pat-hole-2) {\pgfuseplotmark{triangle*}};
  \end{tikzpicture}

  \centering
  \hspace*{\fill}%
  \captionsetup[subfloat]{labelformat=empty}
  \subfloat[]{%
    \makebox[\width]{
      $\begin{aligned}
        &\match (1::\nil) \{ \\
        &\tikzmark{pat-hole-1}|~ \hrul{\nil}{\text{`first rule'}} \\
        &|~ \hrul{\?::xs}{\text{`second rule'}} \\
        &|~ \hrul{2::xs}{\text{`third rule'}} \\
        &\}
      \end{aligned}$
    }
  }%
  $\rightarrow$
  \subfloat[]{
    \makebox[1.2\width]{
      $\begin{aligned}
        &\match (1::\nil) \{ \\
        &|~ \hrul{\nil}{\text{`first rule'}} \\
        &\tikzmark{pat-hole-2}|~ \hrul{\?::xs}{\text{`second rule'}} \\
        &|~ \hrul{2::xs}{\text{`third rule'}} \\
        &\}
      \end{aligned}$
    }
  }%
  $\rightarrow$
  \subfloat[]{
    is indeterminate
  }
  \hspace*{\fill}%
  \caption{Pattern Matching with Expression Holes}
  \label{fig:exp-hole-step}
\end{figure}
\begin{figure}[ht]
  \centering
  \hspace*{\fill}%
  \subfloat[Match expression may be exhaustive.\label{fig:may-exhaust}]{
    \makebox[1.3\width]{
      $\begin{aligned}
        &\match (3::\nil) \{ \\
        &|~ \hrul{\nil}{\text{'first rule'}} \\
        &|~ \hrul{1::xs}{\text{'second rule'}} \\
        &|~ \hrul{\?::xs}{\text{'third rule'}} \\
        &\}
      \end{aligned}$
    }
  }%
  \hfill%
  \subfloat[The third branch may not be redundant.\label{fig:may-not-redundant}]{
    \makebox[1.3\width]{
      $\begin{aligned}
        &\match (1::2::\nil) \{ \\
        &|~ \hrul{\nil}{\text{'first rule'}} \\
        &|~ \hrul{\?::xs}{\text{'second rule'}} \\
        &|~ \hrul{1::2::xs}{\text{'third rule'}} \\
        &\}
      \end{aligned}$
    }
  }%
  \hspace*{\fill}%
  \caption{Static Checking in Incomplete Match Expressions}
  \label{fig:exh-red-hole}
\end{figure}

\section{The Internal Language}
\input{fig-syntax}
\input{fig-pointer-eraser}
\paragraph{Overview.}
\subsection{Typing of Expressions and Patterns}
\input{fig-exptyp}
\input{fig-pattyp}
\subsection{Pattern Matching and Match Constraints}
\input{fig-substyp}
\input{fig-patmatch}
\input{fig-constraint}
\input{fig-satisfy}
\subsection{Redundancy Checking and Typing of Rules}
\input{fig-ruletyp}
\input{fig-rulestyp}
\subsection{Exhaustiveness Checking and Typing of a Match Expression}
Move two typing judgment for match expressions here?
\subsection{Dynamic Semantics}
\input{fig-final}
\input{fig-step}
\clearpage

\bibliographystyle{splncs04}
\bibliography{references.bib}
\end{document}
