\documentclass[acmsmall,screen,review,nonacm]{acmart}

\usepackage{amsmath,amssymb, amsthm}

\usepackage{stmaryrd} % llparenthesis
\usepackage{anyfontsize} % workaround for font size difference warning

%% Joshua Dunfield macros
\def\OPTIONConf{1}
\usepackage{jdunfield}
\usepackage{rulelinks} % hyperlink of rule name

\citestyle{acmauthoryear}

\input{macros}
\input{rulecommands}

\begin{document}
  
\title{Pattern Matching with Holes}

\author{Yongwei Yuan}
\email{slark@umich.edu}
\affiliation{%
  \institution{University of Michigan}
}

\maketitle

\section{Introduction}
\emph{Pattern matching} is a cornerstone of functional programming. An expression of product and sum types often rely on pattern matching to be eliminated.
The expression that corresponds to the concept of pattern matching is called \emph{match} expression. The first argument to match expression is called \emph{scrutinee}, and the second argument consists of a finite sequence of \emph{rule}. Each rule consists of a \emph{pattern} that may introduce variables and an expression that may involve those variables. The meaning of match expression is given by considering each rule in order until the first rule whose pattern matches the scrutinee is found. With the context extended during pattern matching, the expression of the matched rule is computed \cite{Harper2012}.

Pattern matching is widely used in the ML family. However, the way how match expression is structured determine that it requires programmer to deal with many components at the same time, which is impossible. Even worse, throughout the process of entering a match expression, there are substantial lengths of time when the expression is not well-typed by nature.

There have been works that address the problem of such ``gap'' caused by incomplete program. By modeling incomplete programs as typed expression with \emph{holes}, \citet{DBLP:conf/popl/OmarVHAH17} describes a static semantics for incomplete functional programs. Based on that, \citet{DBLP:journals/pacmpl/OmarVCH19} develops a dynamic semantics to evaluate such incomplete programs without exceptions. However, the pattern matching described in the appendix of \citet{DBLP:journals/pacmpl/OmarVCH19} only work with sum types. In other words, it doesn't allow nested patterns, which is the more interesting case and is how pattern matching looks like in modern functional programming languages.

This abstract focuses on the formalism of full-fledged pattern matching with holes such that programming environment or programmer could understand incomplete match expression.

The main contribution of the work is about reasoning the behavior that are specific to pattern matching instead of simply introducing holes into the semantics of pattern matching. In particular, the static semantics is defined in a way to enforce \emph{exhaustivenss} and \emph{redundancy} of rules. In a match expression, there is at least one of the rules that the scrutinee matches or may match. Hence, any well-typed match expression is guaranteed to have no exception. Besides, no rule is definitely redundant with respect to preceding rules, \textit{i.e.}, no rule could be safely eliminated without affecting the execution of pattern matching.

\section{Static Semantics}
\label{sec:statics}

\input{fig-syntax}

\Figref{fig:syntax} define the syntax of the internal language. Note that unless otherwise specified, we are working with the internal language. The external language may be defined in future work to improve user experience.

The match expression $\hmatch{e}{\zrules}$ takes two arguments, the expression to match, $e$, called scrutinee, and a series of rules with pointer, $\zrules$. When a match expression hasn't been evaluated, the pointer is on the first rule. As we consider those rules in order, if the scrutinee doesn't match the pointed rule, the pointer would move to the next rule. The details will be discussed in \Secref{sec:dynamics}.

\input{fig-exptyp}

Since our focus is more on the side of pattern matching, we doesn't inherit the bidirectional static semantics from \citet{DBLP:conf/popl/OmarVHAH17}. Instead, the static semantics aims to predict the behavior of match expression in runtime. For example, the last premise of Rule \TMatchZPre is used to check exhaustivenss, which ensures that the match expression satisfy progress theorem.

\input{fig-rulestyp}

\Figref{fig:rulestyp} defines the type of rules. When rules is constructed inductively in Rule \TRules, the constraints on previous rules is accumulated and the redundancy of each rule is checked in order by comparing the constraint on the current rule, $\xi_r$ with the constraint on previous rules, $\xi_{rs}$.

\input{fig-ruletyp}

\Figref{fig:ruletyp} defines the type of a single rule. Each rule extends the context with the one generated by the pattern and check the typing of the expression. The constraint of a rule is inherited from its pattern.

\input{fig-pattyp}

\Figref{fig:pattyp} specifies the type of patterns and their corresponding constraints. For each well-typed pattern, a constraint is introduced to predict the set of expressions that match the pattern. In particlar, an unknown constraint $?$ is associated with empty or non-empty hole patterns.
\section{Exhaustiveness and Redundancy}
\label{sec:exhaustivens-redundancy}

\section{Dynamic Semantics}
\label{sec:dynamics}
\input{fig-substyp}
\input{fig-patmatch}

\clearpage

\bibliographystyle{ACM-Reference-Format}
\bibliography{references}
\end{document}
