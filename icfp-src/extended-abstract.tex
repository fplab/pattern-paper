\documentclass[acmsmall,screen,review,nonacm]{acmart}

\usepackage{amsmath,amssymb, amsthm}

\usepackage{stmaryrd} % llparenthesis
\usepackage{anyfontsize} % workaround for font size difference warning

\usepackage{cancel} % slash over symbol

\newcommand{\highlight}[1]{\colorbox{yellow}{$\displaystyle #1$}}

\newcommand{\todo}[1]{{\color{red} TODO: #1}}

%% Joshua Dunfield macros
\def\OPTIONConf{1}
\usepackage{jdunfield}
\usepackage{rulelinks} % hyperlink of rule name

\citestyle{acmauthoryear}

\newtheoremstyle{slplain}% name
  {.15\baselineskip\@plus.1\baselineskip\@minus.1\baselineskip}% Space above
  {.15\baselineskip\@plus.1\baselineskip\@minus.1\baselineskip}% Space below
  {\slshape}% Body font
  {\parindent}%Indent amount (empty = no indent, \parindent = para indent)
  {\bfseries}%  Thm head font
  {.}%       Punctuation after thm head
  { }%      Space after thm head: " " = normal interword space;
       %       \newline = linebreak
  {}%       Thm head spec
\theoremstyle{slplain}
\newtheorem{thm}{Theorem}  % Numbered with the equation counter
\numberwithin{thm}{section}
\newtheorem{defn}[thm]{Definition}
\newtheorem{lem}[thm]{Lemma}
\newtheorem{prop}[thm]{Proposition}
\newtheorem{corol}[thm]{Corollary}
\input{macros}
\input{rulecommands}

\begin{document}
  
\title{Pattern Matching with Typed Holes}

\author{Yongwei Yuan}
\email{slark@umich.edu}
\affiliation{%
  \institution{University of Michigan}
}

\authornote{Research advisor: Cyrus Omar; ACM student member number: 9899292; Category: undergraduate}

\maketitle

\section{Introduction}
\label{sec:intro}
Today's programming environment either only provides meaningful feedback for complete programs or simply takes heuristic approach to achieve similar results.
By modeling incomplete programs as typed expressions with \emph{holes}, \citet{DBLP:conf/popl/OmarVHAH17} describes a static semantics for incomplete functional programs. Based on that, \citet{DBLP:journals/pacmpl/OmarVCH19} develops a dynamic semantics to evaluate such incomplete programs without exceptions.

\emph{Pattern matching} is a cornerstone of functional programming languages including ML family. An expression of product or sum types often rely on pattern matching to be eliminated.
However, \citet{DBLP:journals/pacmpl/OmarVCH19} only introduces a rudimentary form of pattern matching that only allows case analysis on binary sum type and doesn't support nested patterns.

\begin{figure}[h]
\begin{minipage}{0.33\textwidth}
\begin{equation}
\begin{split}
  &\mathtt{match} (\hpair{\hinl{\tnum}{\hehole{u}}}{2}) \{\\
  &|~ \hrul{\hpair{\hinrp{x}}{\_}}{x} \\
  &|~ \hrul{\hpair{\_}{x}}{x} \\
  &\}
\end{split}
\label{eq:complete}
\end{equation}
\end{minipage}%
\begin{minipage}{0.33\textwidth}
\begin{equation}
\begin{split}
  &\mathtt{match} (\hpair{\hinl{\tnum}{1}}{2}) \{\\
  &|~ \hrul{\hpair{\hinlp{x}}{\_}}{x} \\
  &|~ \hrul{\hpair{\_}{\hehole{w}}}{\hehole{u}} \\
  &\}
\end{split}
\label{eq:pathole-exhaustive}
\end{equation}
\end{minipage}%
\begin{minipage}{0.33\textwidth}
\begin{equation}
\begin{split}
  &\mathtt{match} (\hpair{\hinl{\tnum}{1}}{2}) \{\\
  &|~ \hrul{\hpair{\hinlp{x}}{\_}}{x} \\
  &|~ \hrul{\hpair{\hinlp{\hehole{w_1}}}{\hehole{w_2}}}{\hehole{u}} \\
  &\}
\end{split}
\label{eq:pathole-redundant}
\end{equation}
\end{minipage}%
\end{figure}

Holes in match expression doesn't have to stop the match expression being evaluated.
For a match expression shown in \Eqref{eq:complete}, the scrutinee contains a hole.
By considering two rules in order, we observe that
no matter how the hole $u$ is filled, $\hpair{\hinl{\tnum}{\hehole{u}}}{2}$ doesn't match $\hrul{\hpair{\hinrp{x}}{\_}}{x}$,
and always matches $\hpair{\_}{x}$. And thus the value of the match expression is $2$.

Besides the computation result, the real time feedback as we enter a match expression can help programmers correct mistakes.
However, it is subtle and complicated to check if the rules in \Eqref{eq:pathole-exhaustive} cover all the possibilities, \ie \emph{exhaustiveness}, or if the second rule in \Eqref{eq:pathole-redundant} can never be reached, \ie \emph{redundancy}. 

This abstract focuses on the formalism of full-fledged pattern matching with typed holes so that the programming environment could give feedback on incomplete match expressions.

\section{Static Semantics}
\label{sec:statics}

\input{fig-exptyp}

Part of the definition of the internal language is shown in \Figref{fig:exptyp}. A match expression takes a sequence of rules with pointer, which is different from the examples in \Secref{sec:intro}. Initially, the pointer is on the first rule (Rule \TMatchZPre). As the match expression is evaluated, we consider those rules in order, if the scrutinee doesn't match the pointed rule, the pointer would move to the next rule. Rule \TMatchNZPre gives the typing judgement for match expressions whose rule pointer has been moved away from the first rule.

Note that the premise of Rule \TMatchZPre and Rule \TMatchNZPre involves judgement of the form $\csatisfyormay{\ctruth}{\xi}$. That means, the rules in match expression is either exhaustive or maybe exhaustive.
Take \Eqref{eq:pathole-exhaustive} as an example, the pattern hole $\hehole{w}$ may be matched by any expression. Therefore, by filling the holes, the rules may cover all the possibilities of scrutinee and we shouldn't generate warning about non-exhaustiveness.

\input{fig-rulestyp}

\Figref{fig:rulestyp} describes the inductive construction of rules. The premise $\cnotsatisfy{\xi_r}{\xi_{pre}}$ in Rule \TRules ensures that rule $r$ is not redundant with respect to rules $rs_{pre}$.
Take \Eqref{eq:pathole-redundant} as an example, all sub-expressions that match or may match $\hinlp{\hehole{w_1}}$ also matches $\hinlp{x}$. Even if the second rule is not complete, we know it is redundant and thus we can suggest the programmer to either rewrite or eliminate it.

\input{fig-patconstraint}

Constraints $\xi$ is emitted from patterns. The syntax of them is given in \Figref{fig:pat-constraint}. A constraint predict the set of expressions that match the corresponding pattern.
For example, \emph{Truth} constraint $\ctruth$ corresponds to variable pattern or wild card pattern that must be matched by all expressions;
\emph{Unknown} constraint $?$ corresponds to pattern hole $\hehole{w}$ or $\hhole{p}{w}$ that may be matched by all expressions;
disconjunction of constraints $\cor{\xi_1}{\xi_2}$ corresponds to multiple patterns.

The dual of a constraint, $\cdual{\xi}$, predicts the complement of the set of expressions that match the corresponding pattern of $\xi$.
\eg $\cdual{\cnum{n}}=\cnotnum{n}$ means all numbers other than $n$;
$\cdual{\cor{\xi_1}{\xi_2}}=\cand{\cdual{\xi_1}}{\cdual{\xi_2}}$ means the complement of the union of two constraints.

To give an idea of how rules is related to constraints:
in \Eqref{eq:pathole-exhaustive}, the corresponding constraint of two rules is $\cor{\cpair{\cinl{\ctruth}}{\ctruth}}{\cpair{\ctruth}{\cunknown}}$;
in \Eqref{eq:pathole-redundant}, the constraint of the second rule is $\cpair{\cinl{\cunknown}}{\cunknown}$ while the constraint of the first rule is $\cpair{\cinl{\ctruth}}{\ctruth}$.
We will see in \Secref{sec:exhaustiveness-redundancy} how these constraints are used to check exhaustiveness and redundancy.

\section{Exhaustiveness and Redundancy}
\label{sec:exhaustiveness-redundancy}

Since constraints correspond to patterns, the relationship between an expression and a constraint should be defined in a way to represent that the expression match the associated pattern of the constraint.

We write $\csatisfy{e}{\xi}$ to denote that the expression $e$ satisfies the constraint $\xi$, which is inductively defined by a set of rules. For example, any expression satisfies Truth constraint, $\csatisfy{e}{\ctruth}$.

Similarly, we inductively define a maybe satisfaction judgement $\cmaysatisfy{e}{\xi}$ to denote that the expression $e$ may satisfy the constraint $\xi$, \ie $e$ may match the associated pattern. For example, an expression hole, no matter it is empty or not, may satisfy any constraint, \ie $\cmaysatisfy{\hehole{u}}{\xi}$ and $\cmaysatisfy{\hhole{e}{u}}{\xi}$, since we can always fill the hole with an expression that matches a given pattern.

Since pattern matching only works with final expressions, the judgements mentioned above only makes sense when $\isFinal{e}$, \ie $\isVal{e}$ or $\isIndet{e}$. $\isIndet{e}$ means that $e$ can't be further evaluated due to the existence of holes \cite{DBLP:journals/pacmpl/OmarVCH19}.

For \Eqref{eq:pathole-exhaustive}, we notice that for any final expression $e$, either 
$\csatisfy{e}{\cpair{\cinl{\ctruth}}{\ctruth}}$ or $\cmaysatisfy{e}{\cpair{\ctruth}{\cunknown}}$.
Therefore, we can say \Eqref{eq:pathole-exhaustive} may be exhaustive. \Definitionref{defn:exhaustiveness} gives the formal definition of exhaustiveness or maybe exhaustiveness.

\begin{defn}[Exhaustiveness or Maybe Exhaustiveness]
  \label{defn:exhaustiveness}
  $\csatisfyormay{\ctruth}{\xi}$ iff $\ctyp{\xi}{\tau}$ and for all $e$ such that $\hexptyp{\cdot}{\Gamma}{e}{\tau}$ and $\isFinal{e}$ we have $\csatisfy{e}{\xi}$ or $\cmaysatisfy{e}{\xi}$.
\end{defn}

By comparing two constraints $\cpair{\cinl{\ctruth}}{\ctruth}$ and $\cpair{\cinl{\cunknown}}{\cunknown}$ that correspond to two rules in \Eqref{eq:pathole-redundant}, we notice that
$\cmaysatisfy{e}{\cpair{\cinl{\cunknown}}{\cunknown}}$ implies $\csatisfy{e}{\cpair{\cinl{\ctruth}}{\ctruth}}$
, which means that no matter how we fill the holes in $\hpair{\hinlp{\hehole{w_1}}}{\hehole{w_2}}$, all expressions that matches the completed pattern also matches $\hpair{\hinlp{x}}{\_}$. Hence, the second rule must be redundant.
\Definitionref{defn:redundancy} gives the formal definition of redundancy.

However, to determine if the redundancy judgement is true, we have to apply \emph{material entailment of constraints} and $\csatisfy{\xi_r}{\xi_{pre}}$ is equivalent to $\csatisfy{\ctruth}{\cor{\cdual{\xi_r}}{\xi_{pre}}}$. Then, we only need to determine if $\cor{\cdual{\xi_r}}{\xi_{pre}}$ can be satisfied by all expressions.

\begin{defn}[Redundancy]
  \label{defn:redundancy}
  $\csatisfy{\xi_r}{\xi_{pre}}$ iff $\ctyp{\xi_r}{\tau}$ and $\ctyp{\xi_{pre}}{\tau}$ and for all $e$ such that $\hexptyp{\cdot}{\Gamma}{e}{\tau}$ and $\isVal{e}$ we have $\csatisfy{e}{\xi_r}$ or $\cmaysatisfy{e}{\xi_r}$ implies $\csatisfy{e}{\xi_{pre}}$.
\end{defn}

While \Definitionref{defn:exhaustiveness} ensures that the scrutinee at least matches or may match one of the constinuent rules, redundancy doesn't have anything to do with the scrutinee, it is simply the property of a single rule with respect to previous rules. Therefore, we only consider the expression that is already a value and recognize the redundant rule with confidence.

\section{Dynamic Semantics}
\label{sec:dynamics}

As for pattern matching, either the scrutinee matches or may match or doesn't match the pattern.
When there are only one remaining rule, the exhaustiveness or maybe exhaustiveness checking ensures that the pattern of the rule either must be match or may be matched by the scrutinee.

\begin{thm}[Preservation]
  \label{thrm:preservation}
  If $\hexptyp{\cdot}{\Delta}{e}{\tau}$ and $\htrans{e}{e'}$
  then $\hexptyp{\cdot}{\Delta}{e'}{\tau}$
\end{thm}

\begin{thm}[Progress]
 \label{thrm:progress}
 If $\hexptyp{\cdot}{\Delta}{e}{\tau}$ then either $\isFinal{e}$ or $\htrans{e}{e'}$ for some $e'$.
\end{thm}

\Theoremref{thrm:preservation} and \Theoremref{thrm:progress} together establishes the type safety of our system.
\Theoremref{thrm:preservation} ensures that no matter where the rule pointer is at, the match expression is still well-typed.
If the pointer is at the first rule (Rule \TMatchZPre), we simply have $\csatisfyormay{e}{\xi}$. Since $\xi$ predicts the set of expressions that match any one of the rules, the scrutinee either matches or may match one of the rules;
If the pointer is not at the first rule (Rule \TMatchNZPre), the premises gives us $\csatisfyormay{e}{\xi_{rest}}$. Besides, $\xi_{rest}$ is the corresponding constraint of the remaining rules, and thus the scrutinee either matches or may match the current rule, or matches or may match one of the rest rules.

Therefore, we conclude that any well-typed match expression can take a step (match) or is indeterminate (may match), which constructs the proof of \Theoremref{thrm:progress}.

\section{Discussion}
The abstract explores how constraint helps reasoning pattern matching with typed holes.
One main contribution of the work is extending the match constraint language \cite{Harper2012} with Unknown constraint and introduce a three-way logic, including the concept of ``maybe''. The other contribution is the formalism of pattern matching with typed holes based on the development of the extended match constraint language.

Next, type holes and dynamic type casting would be added and our type system would be turned into a gradual type system.
Recently, pattern matching statements have also been proposed to be added to \textsf{Python}, whose \emph{Type Hints} is taken from the idea of gradual typing \cite{pep484,pep622,Siek2006}.

As a result, the work lays a foundation for integrating full-fledged pattern matching into the \textsf{Hazel} programming environment described in \citet{DBLP:journals/pacmpl/OmarVCH19}.

\clearpage

\bibliographystyle{ACM-Reference-Format}
\bibliography{references}
\end{document}
